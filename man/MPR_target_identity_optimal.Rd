% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MPR_target_identity.R
\name{MPR_target_identity_optimal}
\alias{MPR_target_identity_optimal}
\alias{MPR_target_identity_semioptimal}
\alias{MPR_target_identity}
\title{Moore-Penrose-Ridge with identity target}
\usage{
MPR_target_identity_optimal(
  Y,
  centeredCov = TRUE,
  verbose = 2,
  eps = 1/(10^6),
  upp = pi/2 - eps
)

MPR_target_identity_semioptimal(Y, centeredCov = TRUE, t, verbose = 2)

MPR_target_identity(Y, centeredCov = TRUE, t, alpha, beta, verbose = 0)
}
\arguments{
\item{Y}{data matrix (rows are features, columns are observations).
TODO: transpose everything.}

\item{centeredCov}{Boolean variable. If \code{TRUE}, the covariance matrix is
computed using centering (i.e. in the general case where the mean of the
random vector may be non-zero).
If \code{FALSE} the covariance matrix is computed assuming that the mean of
the random vector of interest is \code{0} (i.e. does not need to be estimated).}

\item{verbose}{a number indicating whether to print intermediary values and
details about the progress of the computations. A value of \code{0} indicates
no printing at all, while higher values indicate increasingly more detailed
(more verbose) output.}

\item{t, alpha, beta, eps, upp}{\code{t}, \code{alpha} and \code{beta} are
parameters of the estimation. In the optimized version, the loss is optimized
with respect to \eqn{u = arctan(t)} over the interval \code{[eps, upp]}.}
}
\value{
the estimator of the precision matrix, of class
\code{EstimatedPrecisionMatrix}.
}
\description{
This function computes
\deqn{\widehat{\Sigma^{-1}}^{ridge}_t
      = (S + t I_p)^{-1} - t * (S + t I_p)^{-2}},
where \eqn{S} is the sample covariance matrix and \eqn{t} is a given
parameter.
}
\examples{

n = 10
p = 5 * n
mu = rep(0, p)

# Generate Sigma
X0 <- MASS::mvrnorm(n = 10*p, mu = mu, Sigma = diag(p))
H <- eigen(t(X0) \%*\% X0)$vectors
Sigma = H \%*\% diag(seq(1, 0.02, length.out = p)) \%*\% t(H)

# Generate example dataset
X <- MASS::mvrnorm(n = n, mu = mu, Sigma = Sigma)

Y = t(X)

precision_MPR_Cent_optimal = MPR_target_identity_optimal(Y = Y,
                                                         centeredCov = TRUE)
cat("loss = ", FrobeniusLoss2(precision_MPR_Cent_optimal, Sigma = Sigma),
    ", t opt = ", precision_MPR_Cent_optimal$t_optimal, 
    ", alpha opt = ", precision_MPR_Cent_optimal$alpha_optimal,
    ", beta opt = ", precision_MPR_Cent_optimal$beta_optimal, "\n", sep = "")

precision_MPR_Cent = MPR_target_identity(
   Y = Y, centeredCov = TRUE,
   t = precision_MPR_Cent_optimal$t_optimal,
   alpha = precision_MPR_Cent_optimal$alpha_optimal,
   beta = precision_MPR_Cent_optimal$beta_optimal)
   
cat("loss = ", FrobeniusLoss2(precision_MPR_Cent, Sigma = Sigma))

precision_MPR_Cent = MPR_target_identity(
   Y = Y, centeredCov = TRUE,
   t = precision_MPR_Cent_optimal$t_optimal,
   alpha = 1, beta = 0)
   
cat("loss = ", FrobeniusLoss2(precision_MPR_Cent, Sigma = Sigma))

precision_MPR_Cent = MPR_no_shrinkage(Y = Y, centeredCov = TRUE,
                                      t = precision_MPR_Cent_optimal$t_optimal)
cat("loss = ", FrobeniusLoss2(precision_MPR_Cent, Sigma = Sigma))


}
\references{
Nestor Parolya & Taras Bodnar (2024).
Reviving pseudo-inverses: Asymptotic properties of large dimensional
Moore-Penrose and Ridge-type inverses with applications.
\doi{10.48550/arXiv.2403.15792}
}
