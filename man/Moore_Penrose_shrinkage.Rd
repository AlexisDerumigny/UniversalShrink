% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Moore_Penrose_shrinkage.R
\name{Moore_Penrose_shrinkage}
\alias{Moore_Penrose_shrinkage}
\alias{Moore_Penrose_shrinkage_toIP}
\title{First-order shrinkage of the Moore-Penrose inverse towards a general target}
\usage{
Moore_Penrose_shrinkage(Y, Pi0 = NULL, centeredCov, verbose = 0)

Moore_Penrose_shrinkage_toIP(Y, centeredCov, verbose = 0)
}
\arguments{
\item{Y}{data matrix (rows are features, columns are observations).
TODO: transpose everything.}

\item{Pi0}{prior of the precision matrix. This a \code{p} by \code{p} matrix, used as
a target for the shrinkage. Default value is the identity matrix of size \code{p}.
As an advice, it should be a symmetric positive-definite matrix, but this is
not checked for.}
}
\value{
the estimator of the precision matrix
(a \code{p} by \code{p} matrix, i.e. the inverse of the covariance matrix).
It is (asymptotically) optimal for the loss
\eqn{Loss(EstimatorPi) := \| EstimatorPi * \Sigma - I \|_F^2}.
}
\description{
This function computes
\deqn{\alpha \times \widehat{\Sigma^{-1}}^{MP} + (1 - \alpha) \times \Pi_0}
where \eqn{\alpha} is a carefully chosen coefficient,
\eqn{\widehat{\Sigma^{-1}}^{MP}} is the Moore-Penrose inverse of the sample
covariance matrix
and \eqn{\Pi_0} is a given target (for \code{Moore_Penrose_shrinkage()})
or the identity matrix (for \code{Moore_Penrose_shrinkage_toIP()}).
}
\examples{
n = 100
p = 5 * n
mu = rep(0, p)

# Generate Sigma
X0 <- MASS::mvrnorm(n = 10*p, mu = mu, Sigma = diag(p))
H <- eigen(t(X0) \%*\% X0)$vectors
Sigma = H \%*\% diag(seq(1, 0.02, length.out = p)) \%*\% t(H)

# Generate example dataset
X <- MASS::mvrnorm(n = n, mu = mu, Sigma=Sigma)

precision_MoorePenrose_Cent =
   Moore_Penrose_shrinkage(Y = t(X), centeredCov = TRUE)
   
precision_MoorePenrose_NoCent = 
   Moore_Penrose_shrinkage(t(X), centeredCov = FALSE)
   
precision_MoorePenrose_toIPCent = 
   Moore_Penrose_shrinkage_toIP(t(X), centeredCov = TRUE)
   
precision_MoorePenrose_toIPNoCent = 
   Moore_Penrose_shrinkage_toIP(t(X), centeredCov = FALSE)

precisionTrue = solve(Sigma)

estimatedCov_NLshrink = cov_analytical_NL_shrinkage(t(X))
estimatedCov_QISshrink = cov_quadratic_inverse_shrinkage(X)

precision_NLshrink = solve(estimatedCov_NLshrink)
precision_QISshrink = solve(estimatedCov_QISshrink)

FrobeniusLoss2(precision_MoorePenrose_Cent, Sigma = Sigma)
FrobeniusLoss2(precision_MoorePenrose_NoCent, Sigma = Sigma)
FrobeniusLoss2(precision_MoorePenrose_toIPCent, Sigma = Sigma)
FrobeniusLoss2(precision_MoorePenrose_toIPNoCent, Sigma = Sigma)
FrobeniusLoss2(precision_NLshrink, Sigma = Sigma, type = "precision")
FrobeniusLoss2(precision_QISshrink, Sigma = Sigma, type = "precision")

# We now use the true value of the precision matrix as a target for shrinkage
precision_MoorePenrose_Cent_trueSigma = 
  Moore_Penrose_shrinkage(t(X), centeredCov = TRUE, Pi0 = solve(Sigma))
precision_MoorePenrose_NoCent_trueSigma = 
  Moore_Penrose_shrinkage(t(X), centeredCov = FALSE, Pi0 = solve(Sigma))                                                        
                                                        
FrobeniusLoss2(precision_MoorePenrose_Cent_trueSigma, Sigma = Sigma)
FrobeniusLoss2(precision_MoorePenrose_NoCent_trueSigma, Sigma = Sigma)
# this is indeed much closer than before



}
\references{
Nestor Parolya & Taras Bodnar (2024).
Reviving pseudo-inverses: Asymptotic properties of large dimensional
Moore-Penrose and Ridge-type inverses with applications.
\link{https://doi.org/10.48550/arXiv.2403.15792}
}
