% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GMV_Moore_Penrose_target_eq.R,
%   R/GMV_Moore_Penrose_target_general.R
\name{GMV_Moore_Penrose_target_eq}
\alias{GMV_Moore_Penrose_target_eq}
\alias{GMV_Moore_Penrose_target_general}
\title{First-order shrinkage of the Moore-Penrose portfolio towards a general target
portfolio \eqn{\mathbf{b}}}
\usage{
GMV_Moore_Penrose_target_eq(Y, centeredCov = TRUE, verbose = 2)

GMV_Moore_Penrose_target_general(Y, centeredCov = TRUE, b = NULL, verbose = 2)
}
\arguments{
\item{Y}{data matrix (rows are features, columns are observations).
TODO: transpose everything.}

\item{centeredCov}{Boolean variable. If \code{TRUE}, the covariance matrix is
computed using centering (i.e. in the general case where the mean of the
random vector may be non-zero).
If \code{FALSE} the covariance matrix is computed assuming that the mean of
the random vector of interest is \code{0} (i.e. does not need to be estimated).}

\item{verbose}{a number indicating whether to print intermediary values and
details about the progress of the computations. A value of \code{0} indicates
no printing at all, while higher values indicate increasingly more detailed
(more verbose) output.}

\item{b}{shrinkage target}
}
\value{
a vector of size \eqn{p} of (estimated) optimal portfolio weights,
where \eqn{p} is the number of assets.
}
\description{
This function computes
\deqn{\hat{\alpha}^*\times \mathbf{w}_{MP} + (1 - \hat{\alpha}^*) \times \mathbf{b}}
where \eqn{\hat{\alpha}^*} is given by
\deqn{
\hat{\alpha}^*=
\frac{\mathbf{b}^\top\mathbf{S}_n\mathbf{b}-
\frac{\hat{d}_1\left(\mathbf{1}\mathbf{b}^\top\boldsymbol{\Sigma} \right)}
{\hat{d}_1\left(\frac{\mathbf{1}\mathbf{1}^\top}{p}\right)}}
{\mathbf{b}^\top\mathbf{S}_n\mathbf{b} - 
2\frac{\hat{d}_1\left(\mathbf{1}\mathbf{b}^\top\boldsymbol{\Sigma} \right)}
{\hat{d}_1\left( \frac{\mathbf{1}\mathbf{1}^\top}{p}\right)}
+\frac{\hat{d}_3\left(\frac{\mathbf{1}\mathbf{1}^\top}{p}\right)}
{\hat{d}_1^2\left(\frac{\mathbf{1}\mathbf{1}^\top}{p}\right)}},
} where
\deqn{
\hat{d}_1\left(\mathbf{1}\mathbf{b}^\top\boldsymbol{\Sigma}\right)   = \frac{1}{\hat{v}(0)}
\left[\frac{1}{\hat{v}(0)}\left(1-\hat{d}_0(0,\mathbf{1}\mathbf{b}^\top) \right) 
- \hat{d}_1(\mathbf{1}\mathbf{b}^\top) \right],
}
with \eqn{\hat{v}(0)}, \eqn{\hat{d}_1\left( \mathbf{1}\mathbf{b}^\top\right)},
\eqn{\hat{d}_1\left( \frac{\mathbf{1}\mathbf{1}^\top}{p}\right)},
\eqn{d_3(\frac{\mathbf{1}\mathbf{1}^\top}{p})}, and
\eqn{\hat{d}_0\left(0, \mathbf{1}\mathbf{b}^\top\right)} given in (8) and
in (S.41), (S.44), and (S.45)  from the supplement of Bodnar and Parolya (2026).
The vector \eqn{\mathbf{w}_{MP}} are the optimal portfolio weights
estimated as the plug-in of the Moore-Penrose estimate of the precision matrix
and \eqn{\mathbf{1}} is a vector of ones of size \eqn{p}.
}
\examples{
n = 50
p = 2 * n
mu = rep(0, p)

# Generate Sigma
X0 <- MASS::mvrnorm(n = 10*p, mu = mu, Sigma = diag(p))
H <- eigen(t(X0) \%*\% X0)$vectors
Sigma = H \%*\% diag(seq(1, 0.02, length.out = p)) \%*\% t(H)

# Generate example dataset
X <- MASS::mvrnorm(n = n, mu = mu, Sigma=Sigma)

GMV_MP_shrinkage_Cent = 
  GMV_Moore_Penrose_target_eq(Y = t(X), centeredCov = TRUE)
  
GMV_MP_shrinkage_Cent_new = 
  GMV_Moore_Penrose_target_general(Y = t(X), centeredCov = TRUE)
  
# This should coincide with GMV_MP_shrinkage_Cent since by default this is
# shrinked to the equally weighted portfolio.

outOfSampleVariance = t(GMV_MP_shrinkage_Cent) \%*\% Sigma \%*\% GMV_MP_shrinkage_Cent

ones = rep(1, length = p)
V_GMV = 1 / ( t(ones) \%*\% solve(Sigma) \%*\% ones)

Loss_GMV_Moore_Penrose_target_eq = (outOfSampleVariance - V_GMV) / V_GMV

GMV_MP_Cent = GMV_Moore_Penrose(Y = t(X), centeredCov = TRUE)
outOfSampleVariance = t(GMV_MP_Cent) \%*\% Sigma \%*\% GMV_MP_Cent

Loss_GMV_Moore_Penrose = (outOfSampleVariance - V_GMV) / V_GMV

# Shrinkage helps to reduce the loss
stopifnot(Loss_GMV_Moore_Penrose_target_eq < Loss_GMV_Moore_Penrose)


# We now compare with the true target
perfect_GMV_portfolio = GMV_PlugIn(solve(Sigma))

GMV_MP_shrinkage_Cent_oracle = 
  GMV_Moore_Penrose_target_general(Y = t(X), centeredCov = TRUE,
                                   b = perfect_GMV_portfolio)
                                   
outOfSampleVariance = 
  t(GMV_MP_shrinkage_Cent_oracle) \%*\% Sigma \%*\% GMV_MP_shrinkage_Cent_oracle

outOfSampleVarianceGMV = 
  t(perfect_GMV_portfolio) \%*\% Sigma \%*\% perfect_GMV_portfolio

ones = rep(1, length = p)
V_GMV = 1 / ( t(ones) \%*\% solve(Sigma) \%*\% ones)

Loss_GMV_MP_shrinkage_Cent_oracle = (outOfSampleVariance - V_GMV) / V_GMV

cat("GMV_Moore_Penrose_target_eq:", Loss_GMV_Moore_Penrose_target_eq, "\n")
cat("GMV_Moore_Penrose:", Loss_GMV_Moore_Penrose, "\n")
cat("GMV_Moore_Penrose_target_oracle:", Loss_GMV_MP_shrinkage_Cent_oracle, "\n")


# Example of shrinkage to the equally weighted portfolio

GMV_MP_shrinkage_Cent = 
  GMV_Moore_Penrose_target_eq(Y = t(X), centeredCov = TRUE)

GMV_MP_Cent = GMV_Moore_Penrose(Y = t(X), centeredCov = TRUE)

Loss_GMV_Moore_Penrose_target_eq = LossRelativeOutOfSampleVariance(
  portfolioWeights = GMV_MP_shrinkage_Cent, Sigma = Sigma)
  
print(Loss_GMV_Moore_Penrose_target_eq)

Loss_GMV_Moore_Penrose = LossRelativeOutOfSampleVariance(
  portfolioWeights = GMV_MP_Cent, Sigma = Sigma)
  
print(Loss_GMV_Moore_Penrose)

# Shrinkage helps to reduce the loss
stopifnot(Loss_GMV_Moore_Penrose_target_eq < Loss_GMV_Moore_Penrose)


}
\references{
Nestor Parolya & Taras Bodnar (2026).
Reviving pseudo-inverses: Asymptotic properties of large dimensional
Moore-Penrose and Ridge-type inverses with applications.
\doi{10.48550/arXiv.2403.15792}
}
