% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ridge_target_general.R,
%   R/ridge_target_identity.R
\name{ridge_target_general}
\alias{ridge_target_general}
\alias{ridge_target_general_semioptimal}
\alias{ridge_target_general_optimal}
\alias{ridge_target_identity_optimal}
\alias{ridge_target_identity_semioptimal}
\alias{ridge_target_identity}
\title{Ridge with target set to the identity}
\usage{
ridge_target_general(Y, centeredCov, t, Pi0, alpha, beta, verbose = 2)

ridge_target_general_semioptimal(Y, centeredCov, t, Pi0, verbose = 2)

ridge_target_general_optimal(Y, centeredCov, Pi0, verbose = 2)

ridge_target_identity_optimal(Y, centeredCov)

ridge_target_identity_semioptimal(Y, centeredCov, t, verbose = 2)

ridge_target_identity(Y, centeredCov, t, alpha, beta)
}
\arguments{
\item{Y}{data matrix (rows are features, columns are observations).
TODO: transpose everything.}

\item{centeredCov}{Boolean variable. If \code{TRUE}, the covariance matrix is
computed using centering (i.e. in the general case where the mean of the
random vector may be non-zero).
If \code{FALSE} the covariance matrix is computed assuming that the mean of
the random vector of interest is \code{0} (i.e. does not need to be estimated).}

\item{t, alpha, beta}{parameters of the estimation.}

\item{verbose}{a number indicating whether to print intermediary values and
details about the progress of the computations. A value of \code{0} indicates
no printing at all, while higher values indicate increasingly more detailed
(more verbose) output.}
}
\value{
the estimator of the precision matrix
(a \code{p} by \code{p} matrix).
}
\description{
This function computes
\deqn{\alpha \widehat{\Sigma^{-1}}^{ridge}_t + \beta I_p}
where \eqn{\widehat{\Sigma^{-1}}^{ridge}_t = (S + t I_p)^{-1}},
\eqn{S} is the sample covariance matrix,
\eqn{\alpha} and \eqn{\beta} are real-valued coefficients
and \eqn{I_p} is the identity matrix of size \eqn{p}.
}
\details{
The function \code{ridge_target_identity()} requires the specification of all
\eqn{t, \alpha, \beta}.
The function \code{ridge_target_identity_semioptimal()} only requires the
specification of \eqn{t} and compute (asymptotically) optimal choices of
\eqn{\alpha} and \eqn{\beta}.
Finally, the function \code{ridge_target_identity_optimal()} compute the (asymptotically)
optimal choice of \eqn{t, \alpha, \beta}.
}
\examples{

n = 20
p = 5 * n
mu = rep(0, p)

# Generate Sigma
X0 <- MASS::mvrnorm(n = 10*p, mu = mu, Sigma = diag(p))
H <- eigen(t(X0) \%*\% X0)$vectors
Sigma = H \%*\% diag(seq(1, 0.02, length.out = p)) \%*\% t(H)

# Generate example dataset
X <- MASS::mvrnorm(n = n, mu = mu, Sigma=Sigma)
precision_ridge_target_Cent = 
    ridge_target_identity_optimal(Y = t(X), centeredCov = TRUE)
    
precision_ridge_target_NoCent = 
    ridge_target_identity_optimal(Y = t(X), centeredCov = FALSE)

FrobeniusLoss2(precision_ridge_target_Cent, Sigma = Sigma)
FrobeniusLoss2(precision_ridge_target_NoCent, Sigma = Sigma)

precision_ridge_target_Cent_g = 
    ridge_target_general_optimal(Y = t(X), centeredCov = TRUE, Pi0 = diag(nrow = p))
    
precision_ridge_target_NoCent_g = 
    ridge_target_general_optimal(Y = t(X), centeredCov = FALSE, Pi0 = diag(nrow = p))

FrobeniusLoss2(precision_ridge_target_Cent_g, Sigma = Sigma)
FrobeniusLoss2(precision_ridge_target_NoCent_g, Sigma = Sigma)


# TODO: explore the convergence issues with good and bad target.
# This works not as good as the MPR. The MPR takes a lot of time for the
# (classical) optimization using the "L-BFGS-B" algorithm, but has finally
# a smaller (true) loss. This is what we expected because we have a better
# target.

precision_ridge_target_Cent_g_oracle = 
    ridge_target_general_optimal(Y = t(X), centeredCov = TRUE, Pi0 = solve(Sigma))

FrobeniusLoss2(precision_ridge_target_Cent_g_oracle, Sigma = Sigma)

}
\references{
Nestor Parolya & Taras Bodnar (2024).
Reviving pseudo-inverses: Asymptotic properties of large dimensional
Moore-Penrose and Ridge-type inverses with applications.
\doi{10.48550/arXiv.2403.15792}
}
